"""Script to run the RoboChem platform

Aidan Slattery, Pauline Tenblad, Diego Pintossi

This script defines and runs the run_platform function using information the pickle file and experimental_setup.json file
generated by the GUI. There are 7 sections to this script.
1. Import modules and packages
2. Define constants, specifically file paths for pickle files for communicating
between GUI and Platform
3. Connect to devices by creating platform and EagleReactor objects
4. Retrieve information on the vials loaded in the liquid handler
5. Set-up pumps and detectors
6. Define the run_platform function: Wrap the experiment function in a format compatible with BO
7.Main loop to open INPUT PICKLE file and execute run_platform function which loads a sample and saves the output for
the GUI to read

"""

# -----! 1. Import modules and packages !------
import pickle
import copy
import json
from ast import literal_eval

from platform_class import Platform
from List_connected_devices import find_port
from experiment_execution import *
from Liquid_Handler.Sample_info import SampleInfo
from NMR_control_loop.NMR_processing import *
from Pumps_Valves_PS_MFC_LiquidHandler.Pumps_Valves_PS_MFC_LiquidHandler import SamplePreparation
from Syringe_pumps_and_valves_ensemble.Single_pump_and_valve_ensemble import SinglePumpValveEnsemble
from Liquid_Handler import *
from ultrasonic_detector.ultrasonic_pump_detection import UltrasonicDetector
from Concentration_check import calculate_objective_outputs, get_price
from Eagle_Reactor.Eagle_control import EagleReactor
from variable_space import create_variable_space

# -----! 2. Define constants !-----
# pickle file locations to communicate between GUI and Platform code
FILENAME_INPUT_PICKLE = '../input.pickle'  # Same location for frontend and backend. ('..' to move up a folder)
FILENAME_OUTPUT_PICKLE = '../output.pickle'  # Same location for frontend and backend. ('..' to move up a folder)
# location for output data
FILENAME_OUTPUT_CSV = '../all_output.csv'  # Same location for frontend and backend. ('..' to move up a folder)
FILENAME_INIT_PARAMETERS_PICKLE = '../init_parameters.pickle'  # Same location for frontend and backend.
# define sleep parameter for GUI and Platform communication
TIME_SLEEP = 0.5  # [s] The time to sleep inbetween updating the frontend.

# load experimental set up data from experimental_setup.json
# experimental_setup.json is generated by the GUI to inform platform reaction conditions
# TODO: This info is generated with the multi-runs. So for single runs. We also have to generete this file!
SETUP_INFO_JSON = '../experimental_setup.json'
with open(SETUP_INFO_JSON) as json_file:
    experimental_setup = json.load(json_file)

SAMPLE_INFORMATION_FILENAME = experimental_setup["sample_information_filename"]
REACTOR_VOLUME = experimental_setup["reactor_volume"]

# -----! 3. Connect to devices !-----
# [!] PS4-PS6 require manual setup of the COM port name
# connect to platform and pumps
RoboChem = Platform(
    syringe_pump_a={
        'port': find_port('Syringe_pump_A'),
        'baudrate': 38400,
        'name': 'syringe_pump_a'
    },
    syringe_pump_b={
        'port': find_port('Syringe_pump_B'),
        'baudrate': 38400,
        'name': 'syringe_pump_b'
    },
    syringe_pump_c={
        'port': find_port('Syringe_pump_C'),
        'baudrate': 38400,
        'name': 'syringe_pump_c'
    },
    switch_valves={
        'port': find_port('Switch_valves'),
        'pins': [8, 7, 4, 2],
        'name': 'switch_valves',
        'valve types': [
            '3-way', '4-way', '3-way', '4-way'
        ]
    },
    mfc={'port': find_port('MFC')},
)

# connect to photochemical reactor
Eagle = EagleReactor()



# -----! 4. Retrieve information on the vials loaded in the liquid handler !----
sample_information = SampleInfo(
    SAMPLE_INFORMATION_FILENAME  # EXAMPLE: '/Liquid_Handler/20230111_CF3_quinine_AS035.xlsx'
)

sample_information.get_sample_name()
sample_information.get_sample_info()
sample_information.initial_sample_info()
sample_information.get_sample_bottles_number()

# -----! 5. Set-up pumps and detectors !-----
liquid_handling = SamplePreparation(RoboChem)
pump_C = SinglePumpValveEnsemble(RoboChem)
detectors = UltrasonicDetector()

# Set MFC to MAX flow rate (in conjunction with home-made ~1 atm BPR)
asyncio.run(
    liquid_handling.pumps_valves.MFC.define_setpoint(0)
)

# Set 4-way valve next to the NMR to send solvent to waste
asyncio.run(
    RoboChem.switch_valves.valve_4_OFF_or_C_3()
)


# defining sub routine to fill syringes (A+B, C) with solvent
async def fill_up_syringes():
    """Coroutine to fill up all syringes concurrently.
    """

    vol_a, vol_b, vol_c = await asyncio.gather(
        detectors.get_volume(pump='A'),
        detectors.get_volume(pump='B'),
        detectors.get_volume(pump='C')
    )

    print(f'\nPump A: {vol_a} ul  Pump B: {vol_b} ul  Pump C: {vol_c} ul')
    await asyncio.gather(
        liquid_handling.pumps_valves.PumpsValvesEnsemble.ensemble_start_up_no_fill(
            vol_start_a=vol_a,  # volumes in microliters!
            vol_start_b=vol_b,
            diameter_a=14.47,  # SGE syringe (gas-tight) 10 mL
            diameter_b=14.47
        ),
        pump_C.pump_start_up_no_fill(
            vol_start_c=vol_c,
            diameter_c=23.03  # for 25 mL gas-tight syringe
        )
    )


# ------------------------------------------------------------------------------


# -----! 6. Define run_platform function !-----
# #Wrap the experiment function in a format compatible with BO
def run_platform(index, X, objectives, variables):
    """Function to take in GUI generated files with sample composition information,
    run an experiment on the platform and save the output in a format that the GUI can feed back into BO

    :param index:
        identifier index from the pickle file generated by the GUI
    :param X: list
        List containing the sample concentration parameters and the residence
        time.
    :param objectives: str
        string describing required objective function for bayesian optimisation which controls format of
        output pickle file that GUI will use to calculate next point
    :param variables:
        variables space so sampleinfo.py can correctly determine
        in the case that there is a mix of continuous and discrete outputs
    :return: None
    """
    # ------------------------------------------------------------------------------
    # 1. create the variable space for the platform to run from X and variables
    residence_time, eagle_percentage, chemical_space = create_variable_space(X,
                                                                          variables)  # TODO: change the residence time and chemical space using this method

    # 2. turn on the Eagle Reactor
    Eagle.light_on_with_level(level=eagle_percentage)

    # 3. Initialize the platform (connect to instrument, fill syringes)
    asyncio.run(fill_up_syringes())
    asyncio.run(pump_C.refill_syringe())

    # 4. Run experiment and calculate yield (Basic functionality)
    conditions = literal_eval(repr(X))
    measured_exp_yield = asyncio.run(
        single_automated_experiment(
            RoboChem,
            liquid_handling,
            pump_C,
            chemical_space,
            sample_information.prepare_sample_info(chemical_space),
            residence_time,  # residence time (always placed last in the list)
            REACTOR_VOLUME  # global variable from the script
        )
    )

    RoboChem.switch_valves.close()
    RoboChem.mfc.close()
    detectors.close()

    # create a clone as not to have the same filepointer
    conditions_np = copy.deepcopy(X)
    conditions = literal_eval(repr(conditions_np))  # This is used to make sure that the type of the items always is normal python types
    measured_exp_throughput, cost = calculate_objective_outputs(chemical_space,
                                                                residence_time,
                                                                REACTOR_VOLUME,
                                                                measured_exp_yield)
    # 6. Return results
    # get timestamp
    timestamp = f'{ps_data_filename("PS1")[-24:-8]}'
    # choose appropriate output format and save
    if len(objectives) == 1:  # Single objective optimization
        if 'yield' in objectives:
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:
                pickle.dump([index, X, measured_exp_yield, timestamp],
                            filepointer)
        if 'throughput' in objectives:
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:
                pickle.dump([index, X, measured_exp_throughput, timestamp],
                            filepointer)
        if 'cost' in objectives:
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:
                pickle.dump([index, X, cost, timestamp], filepointer)

    if len(objectives) > 1:  # Multi objective optimization
        if 'yield' and 'throughput' in objectives and 'cost' not in objectives:  # yield and throughput
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:
                pickle.dump(
                    [index, X, [measured_exp_yield, measured_exp_throughput],
                     timestamp], filepointer)
        if 'yield' and 'cost' in objectives and 'throughput' not in objectives:  # yield and cost
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:
                pickle.dump(
                    [index, X, [measured_exp_yield, measured_exp_throughput],
                     timestamp], filepointer)
        if 'throughput' and 'cost' in objectives and 'yield' not in objectives:  # throughput and cost
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:  #
                pickle.dump(
                    [index, X, [measured_exp_throughput, cost], timestamp],
                    filepointer)
        if 'yield' and 'throughput' and 'cost' in objectives:  # yield, throughput and cost
            with open(FILENAME_OUTPUT_PICKLE, 'wb') as filepointer:  #
                pickle.dump([index, X,
                             [measured_exp_yield, measured_exp_throughput,
                              cost], timestamp], filepointer)

    return

# -----! 7. Open INPUT PICKLE file and execute run_platform function !-----
if __name__ == '__main__':
    # open the pickle file from the GUI and input the information
    with open(FILENAME_INPUT_PICKLE, 'rb') as filepointer:
        [index_, x_, objectives_, variables_] = pickle.load(filepointer)
    # execute the run platform command
    run_platform(index_, x_, objectives_, variables_)
